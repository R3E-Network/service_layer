#!/bin/bash

# Penetration Testing Script for Neo N3 Service Layer
# This script performs automated penetration testing using various security tools

set -e

echo "Starting penetration testing..."

# Create output directory
OUTPUT_DIR="./security_reports/pentest"
mkdir -p "$OUTPUT_DIR"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# Target configuration - adjust these values based on your environment
TARGET_HOST=${1:-"localhost"}
TARGET_PORT=${2:-"8080"}
TARGET_URL="http://${TARGET_HOST}:${TARGET_PORT}"
TARGET_API="${TARGET_URL}/api/v1"
AUTHENTICATED_TESTS=${3:-"false"}
TEST_USER=${4:-"test@example.com"}
TEST_PASSWORD=${5:-"TestPassword123!"}

# Function to check if a command exists
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Install required tools if not already installed
install_tools() {
  echo "Checking and installing required tools..."
  
  # Check and install OWASP ZAP CLI
  if ! command_exists zap-cli; then
    echo "Installing OWASP ZAP CLI..."
    pip install --user zapcli
  fi

  # Check and install Nikto
  if ! command_exists nikto; then
    echo "Installing Nikto..."
    if command_exists apt-get; then
      sudo apt-get install -y nikto
    elif command_exists brew; then
      brew install nikto
    else
      echo "Please install Nikto manually from https://github.com/sullo/nikto"
      exit 1
    fi
  fi

  # Check and install Nmap
  if ! command_exists nmap; then
    echo "Installing Nmap..."
    if command_exists apt-get; then
      sudo apt-get install -y nmap
    elif command_exists brew; then
      brew install nmap
    else
      echo "Please install Nmap manually from https://nmap.org/download.html"
      exit 1
    fi
  fi

  # Check and install SQLmap
  if ! command_exists sqlmap; then
    echo "Installing SQLmap..."
    pip install --user sqlmap
  fi

  # Check and install curl
  if ! command_exists curl; then
    echo "Installing curl..."
    if command_exists apt-get; then
      sudo apt-get install -y curl
    elif command_exists brew; then
      brew install curl
    else
      echo "Please install curl manually"
      exit 1
    fi
  fi

  # Check and install jq
  if ! command_exists jq; then
    echo "Installing jq..."
    if command_exists apt-get; then
      sudo apt-get install -y jq
    elif command_exists brew; then
      brew install jq
    else
      echo "Please install jq manually from https://stedolan.github.io/jq/download/"
      exit 1
    fi
  fi
}

# Verify target is reachable
verify_target() {
  echo "Verifying target is reachable: ${TARGET_URL}"
  if ! curl -s --head "${TARGET_URL}" > /dev/null; then
    echo "Error: Target ${TARGET_URL} is not reachable"
    exit 1
  fi
  echo "Target is reachable"
}

# Login and get authentication token if authenticated tests are enabled
get_auth_token() {
  if [ "${AUTHENTICATED_TESTS}" = "true" ]; then
    echo "Authenticating to target..."
    
    LOGIN_RESPONSE=$(curl -s -X POST "${TARGET_API}/auth/login" \
      -H "Content-Type: application/json" \
      -d "{\"email\":\"${TEST_USER}\",\"password\":\"${TEST_PASSWORD}\"}")
    
    AUTH_TOKEN=$(echo ${LOGIN_RESPONSE} | jq -r '.token')
    
    if [ "${AUTH_TOKEN}" = "null" ] || [ -z "${AUTH_TOKEN}" ]; then
      echo "Failed to authenticate"
      echo "Response: ${LOGIN_RESPONSE}"
      exit 1
    fi
    
    echo "Successfully authenticated"
    return 0
  else
    echo "Skipping authentication (not enabled)"
    AUTH_TOKEN=""
    return 0
  fi
}

# Run Nmap scan to identify open ports and services
run_nmap_scan() {
  echo "Running Nmap scan on ${TARGET_HOST}..."
  NMAP_OUTPUT="${OUTPUT_DIR}/nmap_${TIMESTAMP}.txt"
  
  nmap -sV -p- -T4 "${TARGET_HOST}" > "${NMAP_OUTPUT}"
  
  echo "Nmap scan completed. Results saved to ${NMAP_OUTPUT}"
}

# Run Nikto to identify web server vulnerabilities
run_nikto_scan() {
  echo "Running Nikto scan on ${TARGET_URL}..."
  NIKTO_OUTPUT="${OUTPUT_DIR}/nikto_${TIMESTAMP}.txt"
  
  nikto -h "${TARGET_URL}" -o "${NIKTO_OUTPUT}" -Format txt
  
  echo "Nikto scan completed. Results saved to ${NIKTO_OUTPUT}"
}

# Run SQLMap to identify SQL injection vulnerabilities
run_sqlmap_scan() {
  echo "Running SQLMap scan on ${TARGET_API}..."
  SQLMAP_OUTPUT="${OUTPUT_DIR}/sqlmap_${TIMESTAMP}"
  mkdir -p "${SQLMAP_OUTPUT}"
  
  # List of endpoints to test
  ENDPOINTS=(
    "/users"
    "/functions"
    "/secrets"
    "/automation/triggers"
    "/price-feed/feeds"
    "/random/requests"
    "/oracle/requests"
  )
  
  for endpoint in "${ENDPOINTS[@]}"; do
    echo "Testing endpoint: ${endpoint}"
    
    HEADERS=""
    if [ -n "${AUTH_TOKEN}" ]; then
      HEADERS="--headers=\"Authorization: Bearer ${AUTH_TOKEN}\""
    fi
    
    sqlmap --url "${TARGET_API}${endpoint}" ${HEADERS} --batch --level=3 --risk=2 --output-dir="${SQLMAP_OUTPUT}" --skip-waf
  done
  
  echo "SQLMap scan completed. Results saved to ${SQLMAP_OUTPUT}"
}

# Run ZAP scan to identify web vulnerabilities
run_zap_scan() {
  echo "Running ZAP scan on ${TARGET_URL}..."
  ZAP_OUTPUT="${OUTPUT_DIR}/zap_${TIMESTAMP}"
  mkdir -p "${ZAP_OUTPUT}"
  
  # Start ZAP daemon
  /usr/local/bin/zap.sh -daemon -port 8090 -host 127.0.0.1 -config api.disablekey=true > /dev/null 2>&1 &
  ZAP_PID=$!
  
  # Wait for ZAP to start
  echo "Waiting for ZAP to start..."
  sleep 10
  
  # Run ZAP scan
  zap-cli -p 8090 open-url "${TARGET_URL}"
  zap-cli -p 8090 spider "${TARGET_URL}"
  zap-cli -p 8090 active-scan -r "${TARGET_API}"
  zap-cli -p 8090 report -o "${ZAP_OUTPUT}/zap_report.html" -f html
  
  # Kill ZAP daemon
  kill ${ZAP_PID}
  
  echo "ZAP scan completed. Results saved to ${ZAP_OUTPUT}/zap_report.html"
}

# Test for common misconfigurations
run_misconfiguration_tests() {
  echo "Testing for common misconfigurations..."
  MISCONFIG_OUTPUT="${OUTPUT_DIR}/misconfiguration_${TIMESTAMP}.txt"
  echo "Common Misconfiguration Test Results" > "${MISCONFIG_OUTPUT}"
  echo "===================================" >> "${MISCONFIG_OUTPUT}"
  echo "Target: ${TARGET_URL}" >> "${MISCONFIG_OUTPUT}"
  echo "Timestamp: $(date)" >> "${MISCONFIG_OUTPUT}"
  echo "" >> "${MISCONFIG_OUTPUT}"
  
  # Check for directory listing
  echo "Checking for directory listing..." | tee -a "${MISCONFIG_OUTPUT}"
  RESP=$(curl -s "${TARGET_URL}/scripts/")
  if [[ "${RESP}" == *"Index of"* ]]; then
    echo "VULNERABLE: Directory listing is enabled" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: Directory listing is disabled" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  echo "" >> "${MISCONFIG_OUTPUT}"
  
  # Check for CORS configuration
  echo "Checking CORS configuration..." | tee -a "${MISCONFIG_OUTPUT}"
  CORS_HEADERS=$(curl -s -I -H "Origin: https://malicious-site.com" "${TARGET_URL}")
  if [[ "${CORS_HEADERS}" == *"Access-Control-Allow-Origin: https://malicious-site.com"* ]]; then
    echo "VULNERABLE: CORS is configured to allow any origin" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: CORS is properly configured" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  echo "" >> "${MISCONFIG_OUTPUT}"
  
  # Check for sensitive headers
  echo "Checking for sensitive headers..." | tee -a "${MISCONFIG_OUTPUT}"
  RESP_HEADERS=$(curl -s -I "${TARGET_URL}")
  if [[ "${RESP_HEADERS}" == *"X-Powered-By"* ]]; then
    echo "ISSUE: X-Powered-By header revealed" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: X-Powered-By header not revealed" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  
  if [[ "${RESP_HEADERS}" == *"Server: "* ]]; then
    echo "ISSUE: Server header revealed" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: Server header not revealed" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  echo "" >> "${MISCONFIG_OUTPUT}"
  
  # Check for common security headers
  echo "Checking for security headers..." | tee -a "${MISCONFIG_OUTPUT}"
  if [[ "${RESP_HEADERS}" != *"Content-Security-Policy"* ]]; then
    echo "ISSUE: Content-Security-Policy header missing" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: Content-Security-Policy header present" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  
  if [[ "${RESP_HEADERS}" != *"X-XSS-Protection"* ]]; then
    echo "ISSUE: X-XSS-Protection header missing" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: X-XSS-Protection header present" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  
  if [[ "${RESP_HEADERS}" != *"X-Content-Type-Options"* ]]; then
    echo "ISSUE: X-Content-Type-Options header missing" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: X-Content-Type-Options header present" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  
  if [[ "${RESP_HEADERS}" != *"Strict-Transport-Security"* ]]; then
    echo "ISSUE: Strict-Transport-Security header missing" | tee -a "${MISCONFIG_OUTPUT}"
  else
    echo "OK: Strict-Transport-Security header present" | tee -a "${MISCONFIG_OUTPUT}"
  fi
  echo "" >> "${MISCONFIG_OUTPUT}"
  
  echo "Misconfiguration tests completed. Results saved to ${MISCONFIG_OUTPUT}"
}

# Test for JWT vulnerabilities
run_jwt_tests() {
  if [ "${AUTHENTICATED_TESTS}" = "true" ] && [ -n "${AUTH_TOKEN}" ]; then
    echo "Testing for JWT vulnerabilities..."
    JWT_OUTPUT="${OUTPUT_DIR}/jwt_${TIMESTAMP}.txt"
    echo "JWT Vulnerability Test Results" > "${JWT_OUTPUT}"
    echo "==========================" >> "${JWT_OUTPUT}"
    echo "Target: ${TARGET_URL}" >> "${JWT_OUTPUT}"
    echo "Timestamp: $(date)" >> "${JWT_OUTPUT}"
    echo "" >> "${JWT_OUTPUT}"
    
    # Decode the JWT and check for algorithm
    JWT_HEADER=$(echo ${AUTH_TOKEN} | cut -d. -f1 | base64 -d 2>/dev/null || echo "{}")
    JWT_ALGORITHM=$(echo ${JWT_HEADER} | jq -r '.alg // "unknown"')
    
    echo "JWT Algorithm: ${JWT_ALGORITHM}" | tee -a "${JWT_OUTPUT}"
    if [[ "${JWT_ALGORITHM}" == "none" ]]; then
      echo "CRITICAL: 'none' algorithm is used" | tee -a "${JWT_OUTPUT}"
    elif [[ "${JWT_ALGORITHM}" == "HS256" ]]; then
      echo "INFO: Using HMAC-SHA256 algorithm" | tee -a "${JWT_OUTPUT}"
    elif [[ "${JWT_ALGORITHM}" == "RS256" ]]; then
      echo "INFO: Using RSA-SHA256 algorithm" | tee -a "${JWT_OUTPUT}"
    fi
    echo "" >> "${JWT_OUTPUT}"
    
    # Test for token expiration
    JWT_PAYLOAD=$(echo ${AUTH_TOKEN} | cut -d. -f2 | base64 -d 2>/dev/null || echo "{}")
    JWT_EXPIRATION=$(echo ${JWT_PAYLOAD} | jq -r '.exp // 0')
    CURRENT_TIME=$(date +%s)
    
    if [[ "${JWT_EXPIRATION}" != "0" ]]; then
      echo "JWT Expiration time: $(date -r ${JWT_EXPIRATION})" | tee -a "${JWT_OUTPUT}"
      if (( JWT_EXPIRATION < CURRENT_TIME )); then
        echo "ISSUE: Token is already expired" | tee -a "${JWT_OUTPUT}"
      elif (( JWT_EXPIRATION - CURRENT_TIME > 86400 )); then
        echo "ISSUE: Token expiration time is more than 24 hours" | tee -a "${JWT_OUTPUT}"
      else
        echo "OK: Token has a reasonable expiration time" | tee -a "${JWT_OUTPUT}"
      fi
    else
      echo "WARNING: Could not determine token expiration" | tee -a "${JWT_OUTPUT}"
    fi
    echo "" >> "${JWT_OUTPUT}"
    
    # Test for token modification
    echo "Testing for token modification..." | tee -a "${JWT_OUTPUT}"
    TAMPERED_TOKEN=$(echo ${AUTH_TOKEN} | sed 's/eyJ/eyj/g')
    TAMPERED_RESP=$(curl -s -o /dev/null -w "%{http_code}" "${TARGET_API}/users" -H "Authorization: Bearer ${TAMPERED_TOKEN}")
    
    if [[ "${TAMPERED_RESP}" == "401" || "${TAMPERED_RESP}" == "403" ]]; then
      echo "OK: Server rejected modified token" | tee -a "${JWT_OUTPUT}"
    else
      echo "CRITICAL: Server accepted modified token" | tee -a "${JWT_OUTPUT}"
    fi
    
    echo "JWT tests completed. Results saved to ${JWT_OUTPUT}"
  else
    echo "Skipping JWT tests (authentication not enabled or failed)"
  fi
}

# Generate a comprehensive HTML report
generate_report() {
  echo "Generating comprehensive HTML report..."
  REPORT_HTML="${OUTPUT_DIR}/pentest_report_${TIMESTAMP}.html"
  
  cat > "${REPORT_HTML}" << EOF
<!DOCTYPE html>
<html>
<head>
  <title>Neo N3 Service Layer - Penetration Testing Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, h2, h3 { color: #333366; }
    .summary { background-color: #f8f8f8; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    .critical { color: #cc0000; }
    .high { color: #ff6600; }
    .medium { color: #ffcc00; }
    .low { color: #00cc00; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    .test-section { margin-bottom: 30px; }
  </style>
</head>
<body>
  <h1>Neo N3 Service Layer - Penetration Testing Report</h1>
  <p>Generated on: $(date)</p>
  
  <div class="summary">
    <h2>Executive Summary</h2>
    <p>This report contains the results of automated penetration testing performed against the Neo N3 Service Layer.</p>
    <p>Target: ${TARGET_URL}</p>
    <p>Tools used:</p>
    <ul>
      <li>Nmap - for port scanning and service detection</li>
      <li>Nikto - for web server vulnerability scanning</li>
      <li>SQLMap - for SQL injection testing</li>
      <li>OWASP ZAP - for web application vulnerability scanning</li>
      <li>Custom tests - for security misconfigurations and JWT vulnerabilities</li>
    </ul>
  </div>
  
  <div class="test-section">
    <h2>Nmap Scan Results</h2>
    <pre>$(cat "${OUTPUT_DIR}/nmap_${TIMESTAMP}.txt" 2>/dev/null || echo "No results available")</pre>
  </div>
  
  <div class="test-section">
    <h2>Nikto Scan Results</h2>
    <pre>$(cat "${OUTPUT_DIR}/nikto_${TIMESTAMP}.txt" 2>/dev/null || echo "No results available")</pre>
  </div>
  
  <div class="test-section">
    <h2>SQLMap Scan Results</h2>
    <p>SQLMap results are stored in separate files in the ${OUTPUT_DIR}/sqlmap_${TIMESTAMP} directory.</p>
  </div>
  
  <div class="test-section">
    <h2>OWASP ZAP Scan Results</h2>
    <p>ZAP results are available in HTML format at ${OUTPUT_DIR}/zap_${TIMESTAMP}/zap_report.html</p>
  </div>
  
  <div class="test-section">
    <h2>Security Misconfiguration Test Results</h2>
    <pre>$(cat "${OUTPUT_DIR}/misconfiguration_${TIMESTAMP}.txt" 2>/dev/null || echo "No results available")</pre>
  </div>
  
  <div class="test-section">
    <h2>JWT Vulnerability Test Results</h2>
    <pre>$(cat "${OUTPUT_DIR}/jwt_${TIMESTAMP}.txt" 2>/dev/null || echo "No results available")</pre>
  </div>
  
  <h2>Recommendations</h2>
  <p>Based on the penetration test results, consider implementing the following security improvements:</p>
  <ul>
    <li>Ensure all security headers are properly configured</li>
    <li>Implement rate limiting to prevent brute force attacks</li>
    <li>Use secure JWT practices with appropriate algorithms and expiration times</li>
    <li>Close unnecessary open ports and disable unused services</li>
    <li>Regularly update all dependencies to the latest secure versions</li>
    <li>Implement input validation for all user-supplied data</li>
    <li>Configure CORS settings properly to prevent cross-origin attacks</li>
    <li>Implement proper error handling to prevent information leakage</li>
  </ul>
  
  <footer>
    <p>Neo N3 Service Layer - Penetration Testing Report - Generated by pentest.sh</p>
  </footer>
</body>
</html>
EOF

  echo "HTML report generated: ${REPORT_HTML}"
}

# Main execution
main() {
  install_tools
  verify_target
  get_auth_token
  
  run_nmap_scan
  run_nikto_scan
  run_sqlmap_scan
  run_zap_scan
  run_misconfiguration_tests
  run_jwt_tests
  
  generate_report
  
  echo "Penetration testing completed. All reports saved to ${OUTPUT_DIR}"
  echo "Summary report: ${OUTPUT_DIR}/pentest_report_${TIMESTAMP}.html"
}

main 